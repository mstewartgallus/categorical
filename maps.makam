maps : term -> term -> term -> prop.

maps object terminal kind.

(* Allow User Defined Axioms *)
maps (axiom _ A B) A B.

(* Basic Rules of Categories *)
maps (id A) A A.
maps (compose F G) A C :-
    maps F B C,
    maps G A B.

(* Terminal/Initial Objects *)

(* FIXME Terminal having a domain of terminal seems oddly circular *)
maps terminal terminal object.
maps (bang A) A terminal.

maps initial terminal object.
maps (absurd A) initial A.

(* Functions/Dependent Products *)
maps (forall A Body) terminal object :-
    (var:term -> maps var terminal A -> maps (Body var) terminal object).
maps (zeta A Body) B (forall A C) :-
    (var:term -> maps var terminal A -> maps (Body var) B (C var)).
maps (pass F X) C (B X) :-
    maps X terminal A,
    maps F C (forall A B).

(* Tuples/Dependent Sum *)
maps (exists A Body) terminal object :-
    (var:term -> maps var terminal A -> maps (Body var) terminal object).
maps (kappa A Body) (exists A B) C :-
    (var:term -> maps var terminal A -> maps (Body var) (B var) C).
maps (lift F X) (B X) C :-
    maps X terminal A,
    maps F (exists A B) C.

(* Coexponentials/? *)
maps (coforall A Body) terminal object :-
    (var:term -> maps var A initial -> maps (Body var) terminal object).
maps (cozeta A Body) (coforall A C) B :-
    (var:term -> maps var A initial -> maps (Body var) (C var) B).
maps (copass F X) (B X) C :-
    maps X A initial,
    maps F (coforall A B) C.

(* Sums/? *)
maps (coexists A Body) terminal object :-
    (var:term -> maps var A initial -> maps (Body var) terminal object).
maps (cokappa A Body) C (coexists A B) :-
    (var:term -> maps var terminal A -> maps (Body var) C (B var)).
maps (colift F X) C (B X) :-
    maps X A initial,
    maps F C (coexists A B).
