multistep : term -> term -> prop.

step : term -> term -> prop.
step_ : term -> term -> prop.
step_compose : term -> term -> term -> prop.

apply : term -> term -> term -> prop.

multistep X Z :-
    if step X Y
    then multistep Y Z
    else unify X Z.

step X Y :-
    if step_ X Y then success else structural @step_ X Y.

(* FIXME reassociate *)
step_ (compose F G) Y :-
    apply F G Y.

apply (id _) X X.
apply X (id _) X.

(* FIXME type inference ? *)
apply (bang _) _ (bang _).
apply _ (absurd _) (absurd _).

(* FIXME do better lift/pass rules *)
apply (kappa A F) (lift (id A) X) (F X).
apply (lift (id A) X) (zeta A F) (F X).

apply (zeta A F) X (zeta A (fun y => compose (F y) X)).
apply X (kappa A F) (kappa A (fun y => compose X (F y))).
