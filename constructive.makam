(* Define a constructive fragment of our language *)
(* FIXME use structural recursion instead? *)

constructive : term -> prop.

constructive (id A) :- constructive A.
constructive (compose A B) :-
    constructive A,
    constructive B.

(* We cant know if your axioms are constructive but we have to have this *)
constructive (axiom _ _ _).

constructive terminal.
constructive (bang A) :- constructive A.

constructive initial.
constructive (absurd A) :- constructive A.

constructive (forall A F) :-
    constructive A,
    (x:term -> constructive x -> constructive (F x)).
constructive (zeta A F) :-
    constructive A,
    (x:term -> constructive x -> constructive (F x)).
constructive (pass F X) :- constructive F, constructive X.

constructive (exists A F) :-
    constructive A,
    (x:term -> constructive x -> constructive (F x)).
constructive (kappa A F) :-
    constructive A,
    (x:term -> constructive x -> constructive (F x)).
constructive (lift F X) :- constructive F, constructive X.

(* My intuition is that this would correspond to sum types and
probably be constructive but I am not totally sure *)

constructive (coexists A F) :-
    constructive A,
    (x:term -> constructive x -> constructive (F x)).
constructive (cokappa A F) :-
    constructive A,
    (x:term -> constructive x -> constructive (F x)).
constructive (colift F X) :- constructive F, constructive X.
