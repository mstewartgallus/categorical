check : term -> term -> term -> prop.

dom : term -> term -> prop.
dom X A :- check X A _.

cod : term -> term -> prop.
cod X B :- check X _ B.

(* Allow User Defined Axioms *)
check (axiom _ A B) A B.

check set _ object.

(* Basic Rules of Categories *)
check id A A.
check (compose F G) A C :-
    check F B C,
    check G A B.

check terminal _ set.
check bang _ terminal.

check initial _ set.
check absurd initial _.

(* Functions/Dependent Products *)
check (forall A Body) _ L :-
    check A terminal _,
    (x:term -> check x terminal A -> check (Body x) terminal L).

check (zeta A Body) B (forall A C) :-
    check A terminal _,
    (x:term -> check x terminal A -> check (Body x) B (C x)).
check (pass X) (forall A B) (B X) :-
    check X terminal A.

(* Tuples/Dependent Sum *)
check (exists A Body) _ L :-
    check A terminal _,
    (x:term -> check x terminal A -> check (Body x) terminal L).
check (kappa A Body) (exists A B) C :-
    check A terminal _,
    (x:term -> check x terminal A -> check (Body x) (B x) C).
check (lift X) (B X) (exists A B) :-
    (check X terminal A).

(* Coexponentials? *)
check (coforall A Body) _ L :-
    check A terminal _,
    (x:term -> check x A initial -> check (Body x) terminal L).
check (cozeta A Body) (coforall A C) B :-
    check A terminal _,
    (x:term -> check x A initial -> check (Body x) (C x) B).
check (copass X) (B X) (coforall A B) :-
    (check X A initial).

(* Cotuples? *)
check (coexists A Body) _ L :-
    check A terminal _,
    (x:term -> check x A initial -> check (Body x) terminal L).
check (cokappa A Body) C (coexists A B) :-
    check A terminal _,
    (x:term -> check x initial A -> check (Body x) C (B x)).
check (colift X) (coexists A B) (B X) :-
    check X A initial.

(* FIXME Add Normalization to Typechecking *)

(* Normalization *)

multistep : term -> term -> prop.

step : term -> term -> prop.
step_ : term -> term -> prop.

apply : term -> term -> term -> prop.

multistep X Z :-
    if step X Y
    then multistep Y Z
    else unify X Z.

step X Y :-
    if step_ X Y
    then success
    else structural @step_ X Y.

step_ (compose F G) Y :-
    apply F G Y.

apply id X X.
apply X id X.

apply bang _ bang.
apply _ absurd absurd.

apply (kappa A F) (lift X) (F X) :-
    (any:term -> check X any A).
apply (lift X) (zeta A F) (F X) :-
    (any:term -> check X any A).

apply (cozeta A F) (copass X) (F X) :-
    (any:term -> check X A any).
apply (colift X) (cokappa A F) (F X) :-
    (any:term -> check X A any).

apply (zeta A F) X (zeta A (fun y => compose (F y) X)).
apply X (kappa A F) (kappa A (fun y => compose X (F y))).

apply X (cozeta A F) (cozeta A (fun y => compose X (F y))).
apply (cokappa A F) X (cokappa A (fun y => compose (F y) X)).
