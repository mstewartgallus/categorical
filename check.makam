check : term -> term -> term -> prop.

dom : term -> term -> prop.
dom X A :- check X A _.

cod : term -> term -> prop.
cod X B :- check X _ B.

(* Allow User Defined Axioms *)
check (axiom _ A B) A B.

check set _ object.

(* Basic Rules of Categories *)
check (id A) A A.
check (compose F G) A C :-
    check F B C,
    check G A B.

check terminal _ set.
check (bang A) A terminal.

check initial _ set.
check (absurd A) initial A.

(* Functions/Dependent Products *)
check (forall A Body) _ L :-
    check A terminal _,
    (x:term -> check x terminal A -> check (Body x) terminal L).

check (zeta A Body) B (forall A C) :-
    check A terminal _,
    (x:term -> check x terminal A -> check (Body x) B (C x)).
check (pass F X) C (B X) :-
    check X terminal A,
    check F C (forall A B).

(* Tuples/Dependent Sum *)
check (exists A Body) _ L :-
    check A terminal _,
    (x:term -> check x terminal A -> check (Body x) terminal L).
check (kappa A Body) (exists A B) C :-
    check A terminal _,
    (x:term -> check x terminal A -> check (Body x) (B x) C).
check (lift F X) (B X) C :-
    check X terminal A,
    check F (exists A B) C.

(* Coexponentials? *)
check (coforall A Body) _ L :-
    check A terminal _,
    (x:term -> check x A initial -> check (Body x) terminal L).
check (cozeta A Body) (coforall A C) B :-
    check A terminal _,
    (x:term -> check x A initial -> check (Body x) (C x) B).
check (copass F X) (B X) C :-
    check X A initial,
    check F (coforall A B) C.

(* Cotuples? *)
check (coexists A Body) _ L :-
    check A terminal _,
    (x:term -> check x A initial -> check (Body x) terminal L).
check (cokappa A Body) C (coexists A B) :-
    check A terminal _,
    (x:term -> check x initial A -> check (Body x) C (B x)).
check (colift F X) C (B X) :-
    check X A initial,
    check F C (coexists A B).

(* FIXME Add Normalization to Typechecking *)

(* Normalization *)

multistep : term -> term -> prop.

step : term -> term -> prop.
step_ : term -> term -> prop.

apply : term -> term -> term -> prop.

multistep X Z :-
    if step X Y
    then multistep Y Z
    else unify X Z.

step X Y :-
    if step_ X Y
    then success
    else structural @step_ X Y.

step_ (compose F G) Y :-
    apply F G Y.

step (lift (kappa A F) X) (F X) :-
    check X terminal A.
step (pass (zeta A F) X) (F X) :-
    check X terminal A.
step (colift (cokappa A F) X) (F X) :-
    check X A initial.
step (copass (cozeta A F) X) (F X) :-
    check X A initial.

apply (id A) X X :-
    check X _ A.
apply X (id A) X :-
    check X A _.

apply (bang B) X (bang A) :-
    check X A B.
apply X (absurd A) (absurd B) :-
    check X A B.

apply Y (lift F X) (lift (compose Y F) X).
apply (pass F X) Y (pass (compose F Y) X).

apply (colift F X) Y (colift (compose Y F) X).
apply Y (copass F X) (copass (compose F Y) X).

apply (zeta A F) X (zeta A (fun y => compose (F y) X)).
apply X (kappa A F) (kappa A (fun y => compose X (F y))).

apply X (cozeta A F) (cozeta A (fun y => compose X (F y))).
apply (cokappa A F) X (cokappa A (fun y => compose (F y) X)).
